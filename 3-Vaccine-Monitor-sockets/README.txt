Bash script 


Διαβάζει το inputFile που του δίνεται μία μία γραμμή και ανάλογα την χώρα του record το γράφει στο επόμενο 
αρχείο της χώρας με σειρά round robin. Αν δεν υπάρχει ο φάκελος της χώρας δημιουργείται με mkdir και 
αρχικοποιείται ο δείκτης στο επόμενο αρχείο. Αν δεν υπάρχει το συγκεκριμένο αρχείο χώρας δημιουργείται εκείνη
 την στιγμή με το append (>>). 


Πρόγραμμα C

Μεταγλώττιση και εκτέλεση:
$ make
στον αρχικό φάκελο για Μεταγλώττιση.
$ make run
για εκτέλεση με τα ορίσματα που έχουν οριστεί στο makefile
ή
$ ./build/travelMonitorClient -m 5 -b 100 -c 30 -s 100000 -i input_dir4 -t 1
$ make valgrind 
για εκτέλεση με valgrind.

Υποθέτω ότι η είσοδος από το inputFile είναι σωστή, δηλαδή ότι κάθε πολίτης είναι σε μόνο μία χώρα και ότι 
γενικά δεν υπάρχουν inconsistencies στα πρώτα 5 πεδία των εγγραφών, επειδή κάθε monitor έχει συγκεκριμένες 
χώρες και δεν μπορεί να ανιχνεύει inconsistencies σε διαφορετικές χώρες. Επίσης, για την 3η εργασία υποθέτω 
ότι δεν υπάρχουν inconsistencies ούτε στα υπόλοιπα πεδία, π.χ. αν υπάρχει μία εγγραφή που δηλώνει ότι ένας 
συγκεκριμένος πολίτης εμβολιάστηκε για τον COVID-19, τότε δεν υπάρχει εγγραφή για τον ίδιο πολίτη που λέει 
ότι δεν εμβολιάστηκε ή ότι εμβολιάστηκε σε διαφορετική ημερομηνία (όπως αναφέρεται και στην εκφώνηση). Η 
συνάρτηση update_structures εχει ενημερωθεί λαμβάνοντας υπόψη τα προηγούμενα. Για την παραγωγή του 
inputFile.txt χρησιμοποίησα το script της 1ης εργασίας με duplicatesAllowed=0 και 10000 γραμμές ώστε να μην 
υπάρχουν inconsistencies.


Χρησιμοποίησα execv για την εκτέλεση των monitors καθώς δεν είναι σταθερός ο αριθμός των φακέλων των χωρών. 
Βάζω στον πίνακα πρώτα τα ορίσματα όπως το port, socket buffer size κλπ και μετά τα paths των υποφακέλων των 
χωρών.


Επικοινωνία μέσω sockets
Το πρωτόκολλο επικοινωνίας είναι παρόμοιο με αυτό της 2ης εργασίας, εκτός από τις αρχικές πληροφορίες που 
τώρα στέλνονται με την exec.


Όλα τα μηνύματα που ανταλλάσσονται γίνονται μέσω των συναρτήσεων send_message και receive_message που 
υλοποίησα, και φαίνονται στο αρχείο common.h και common.c. Στην send_message στέλνεται πρώτα το μέγεθος του 
μηνύματος προς αποστολή ανά buffer_size bytes που είναι μεγέθους int και το διαβάζει η receive_message 
ξέροντας ότι το μέγεθος είναι int. Έπειτα στέλνετε το πραγματικό μήνυμα και η receive, αφού ξέρει το μέγεθος 
από το προηγούμενο μήνυμα που αντάλλαξαν, ξέρει πόσα bytes να περιμένει. 
Σημείωση: Έγινε μία αλλαγή σε αυτή την συνάρτηση σε σχέση με την 2η εργασία. Για να σταλεί/παραληφθεί ένα 
ολόκληρο μήνυμα σε socket_buffer_size πακέτα υπάρχουν πλέον 2 loops, το πρώτο  που στέλνει/παραλαμβάνει σε 
socket_buffer_size μέγεθος και το 2ο που στέλνει παραλαμβάνει σε μέγεθος των υπολοιπόμενων 
bytes < socket_buffer_size (στην 2η εργασία το 2o ηταν if καθώς υπέθετα ότι κάθε φορά διαβάζονται/γράφονται 
ακριβώς τα bytes που ορίζονταν μέσα στο write/read και λειτουργούσε σωστά για named pipes). Σε αυτήν την 
εργασία λόγω των sockets δεν διαβάζονταν όλα τα bytes σε κάποιες περιπτώσεις (σε μεγάλες παραμετρους πχ 
-b 1000000 -s 1000000), οπότε βρήκα αυτή την λύση (αντί να χρησιμοποιήσω send και recv με καταλληλα flag).


Οι ενέργειες μέχρι το σημείο των εντολών από τον χρήστη γίνονται με συγκεκριμένη σειρά οπότε μετά από κάθε 
"ενότητα" μηνυμάτων στέλνετε ένα μήνυμα END ώστε να ενημερώσει η μία διεργασία την άλλη ότι τελείωσε αυτή 
η ενέργεια και να προχωρήσει στην επόμενη. 


Αφού δημιουργήσει όλα τα παιδιά, το travelMonitorClient περιμένει τα monitor να ανοίξουν κάθε αρχείο στα 
directories που τους έχουν ανατεθεί και να ενημερώσουν κατάλληλα τις δομές που κρατάνε τις πληροφορίες (αυτό 
γίνεται με την συνάρτηση update_structures που περιλαμβάνει το αντίστοιχο κομμάτι κώδικα της πρώτης εργασίας, 
και χρησιμοποιεί τις ίδιες δομές), να στείλουν πίσω τα bloomfilters για κάθε ίωση την οποία έφτιαξαν. Εδώ 
χρησιμοποιώ την συνάρτηση select έτσι ώστε να διαβάζονται πρώτα τα πιο γρήγορα monitor και να γίνεται πιο 
γρήγορα η διαδικασία συνολικά. Το travelMonitor περιμένει ένα END από κάθε monitor ώστε να περάσει στο επόμενο 
monitor ή να τερματίσει την διαδικασία αν έχει πάρει ένα από κάθε monitor. Το travelMonitorClient περιμένει 
τώρα εντολές από το χρήστη και κάθε monitor περιμένει εντολές/πληροφορίες από το travelMonitorClient μέσω των 
sockets. 




Για την αποστολή των bloomfilters γίνεται serialization στην αποστολή και deserialization στην παραλαβή 
επειδή περιέχει pointer, και θεωρείται γνωστή η δομή του (στο bloom_filter.h) για πιο εύκολη διαχείριση. 
Αυτές οι δύο συναρτήσεις βρίσκονται στο common.c.


send_bloomfilters (monitorServer.c)
Η συνάρτηση στέλνει τα bloom filters που δίνονται μέσα στο hash table. Για την πρόσβαση στα στοιχεία του 
hash table χρησιμοποιείται η συνάρτηση Hash_getNextEntry, οπότε χρειάζεται να προστατευθεί με το ίδιο mutex 
που χρησιμοποιείται για το hash table από την update_structures.


bloomfilter_add (bloomfilter.h)
Το travelMonitorClient κρατάει μόνο τα bloom filters με key τον ιό στον οποίο ανήκουν. Υπάρχει μόνο ένα 
bloomfilter για έναν ιό. Αν έρθει ένα bloomfilter για ιό που ήδη υπάρχει τότε γίνεται bitwise OR ώστε να 
συγχωνευτούν σε ένα bloomfilter.


update_structures και mutexes (functions.c)
Έγινε τροποποίηση στον κώδικα της 1ης εργασίας ώστε η update_structures να παίρνει σαν όρισμα ένα hash table 
με τα updated entries που έχουν τροποποιήσει το πεδίο bloomfilters. Για την 3η εργασία όπως αναφέρθηκε 
παραπάνω τροποποιήθηκε ο κώδικας της συνάρτησης χωρίς να ελέγχει για τυχόν ασυνεπείς εγγραφές. Για αυτό το 
κομμάτι χρησιμοποιούνται 2 mutexes ενας για την τροποποίηση του hash table που περιέχει πληροφορίες για 
πολίτες και ένα για την τροποποίηση του vaccine table. Το κομμάτι που ενημερώνει το hash table με τις updated
 εγγραφές βρίσκεται μέσα στο critical section μαζί με το vaccine table επειδή χρησιμοποιεί δείκτες του 
vaccine table. Επίσης υπάρχει ένα ξεχωριστό mutex για την strtok καθώς δεν είναι thread safe.


Cyclic buffer και threads (monitorServer.c)
Τα threads δημιουργούνται ως consumers επειδή παίρνουν αντικείμενα από τον buffer και το κύριο thread 
λειτουργεί ως producer. Το κύριο thread αφού δημιουργήσει τα υπόλοιπα threads ανοίγει τα directories που 
έχουν δοθεί ως ορίσματα στην main, φτιάχνει τα paths για κάθε αρχείο και τα βάζει (με την συνάρτηση 
producer) στο buffer. Η συνάρτηση consumer είναι η λειτουργία που κάνει ένα thread. Παίρνει ένα path από 
το buffer, ανοίγει το αρχείο ενημερώνει τις κοινές δομές μέσω της update_structures η οποία περιγράφεται 
πάνω. Η διαδικασία λειτουργεί γενικά σαν το πρόβλημα των producers-consumers αλλά υπάρχει μόνο ένας consumer 
και πολλοί producer.


Εντολές
Η /exit είναι ο μοναδικός τρόπος να τερματίσει το πρόγραμμα. Το travelMonitorClient προωθεί την εντολή σε 
όλα τα monitorServers και σπάει το loop και περιμένει τα παιδιά να τερματίσουν. Ένα monitorServer όταν λάβει 
εντολή /exit σπάει το loop του, τερματίζει τα threads απελευθερώνει την μνήμη και τερματίζει.


Στο /travelRequest πρώτα ελέγχεται αν τα ορίσματα είναι της σωστής μορφής, και έπειτα ελέγχεται επίσης αν 
υπάρχουν οι χώρες countryFrom και countryTo. Αν έστω μία από τις δυο δεν υπάρχει εκτυπώνεται μήνυμα. Αν ο ιός
 δεν υπάρχει τότε αυτό θα βρεθεί γιατί δεν θα υπάρχει κλειδί με το όνομα του ιού στο hash table των 
 bloomfilters οπότε εκτυπώνεται μήνυμα.


Στο /travelStats δεν ελέγχεται αν δεν υπάρχει η χώρα που δίνεται, απλά αν δεν υπάρχει δεν θα αυξηθούν ποτέ οι 
μετρητές των rejected και accepted και η έξοδος θα γράφει ότι τα accepted και rejected είναι 0. Τα stats 
μετρουνται με τις συναρτήσεις του stats.h.


Στο /addVaccinationRecords το travelMonitorClient προωθεί την εντολή στο monitorServer που διαχειρίζεται το 
συγκεκριμένο directory. Αυτό βρίσκει τα καινούρια αρχεία χρησιμοποιώντας το hash table read_files και τα 
βάζει στο buffer ωστε να τα πάρουν τα threads. Τα threads ανανεώνουν τις δομές και βάζουν μέσω της 
update_structures τα ενημερωμένα αντικείμενα του vaccine table στην δομή updated.  Το monitorServer στέλνει 
πίσω στο travelMonitorClient μόνο τα bloom filters τα οποία υπέστησαν αλλαγές. Αυτά το travelMonitorClient 
τα προσθέτει στα ήδη υπάρχοντα bloomfilter με την bloomfilter_add.


Στο /searchVaccinationStatus το travelMonitorClient  προωθεί το αίτημα σε όλα τα monitors μέσω sockets. Τα 
monitors κοιτάνε στο hash table των πολιτών. Μόνο σε ένα (ή κανένα) monitor θα βρεθεί ο πολίτης με το id 
επειδή έχουμε υποθέσει ότι ένας πολίτης έχει πάντα τα 5 πεδία του (citizenID firstName lastName country age) 
σωστά, χωρίς inconsistencies, διότι αλλιώς τα monitors θα έπρεπε να είχαν και επικοινωνία μεταξύ τους για να 
απορρίψουν τον πολίτη, πράγμα το οποίο δεν συμβαίνει. Έτσι μόνο το monitor το οποίο διαχειρίζεται την χώρα 
αυτού του citizenID θα απαντήσει. To travelMonitorClient χρησιμοποιεί την select για να βρει το pipe από το 
οποίο του έρχεται η απάντηση. Για την περίπτωση που το citizenID δεν υπάρχει σε κανένα monitor έχει οριστεί 
με το struct timeval ένα timeout στην select (5 δευτερολέπτων).


Logfiles
Το travelMonitorClient όταν δέχεται ή απορρίπτει αίτημα από την travelRequest στέλνει στο monitor που 
διαχειρίζεται την χώρα countryTo ACCEPTED η REJECTED ωστε το monitor να ενημερώσει τον μετρητή του. To 
travelMonitorClient εχει 2 δικους του μετρητές για το logfile. Τα accepted και rejected των monitors, 
αν αθροιστούν δίνουν αυτά του travelMonitorClient .
