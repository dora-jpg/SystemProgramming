Bash script 

Ενδεικτική εκτέλεση:
$ ./create_infiles.sh inputFile.txt input_dir 5

Διαβάζει το inputFile που του δίνεται μία μία γραμμή και ανάλογα την χώρα του record το γράφει στο επόμενο 
αρχείο της χώρας με σειρά round robin. Αν δεν υπάρχει ο φάκελος της χώρας δημιουργείται με mkdir και 
αρχικοποιείται ο δείκτης στο επόμενο αρχείο. Αν δεν υπάρχει το συγκεκριμένο αρχείο χώρας δημιουργείται εκείνη
 την στιγμή με το append (>>). 


Πρόγραμμα C

Μεταγλώττιση: Στον τρέχον κατάλογο συμπεριλαμβάνεται makefile.
$ make

Εκτέλεση: Το εκτελέσιμο δημιουργείται στον φάκελο build.
Ενδεικτική εκτέλεση:
$ make run 
ή
$ ./build/travelMonitor -i input_dir -s 100000 -b 100 -m 3

Υποθέτω ότι η είσοδος από το inputFile είναι σωστή, δηλαδή ότι κάθε πολίτης είναι σε μόνο μία χώρα και ότι 
γενικά δεν υπάρχουν inconsistencies στα πρώτα 5 πεδία των εγγραφών, επειδή κάθε monitor έχει συγκεκριμένες 
χώρες και δεν μπορεί να ανιχνεύει inconsistencies σε διαφορετικές χώρες.

Επικοινωνία μέσω named pipes

Το πρώτο μήνυμα που στέλνει το travelMonitor σε κάθε Monitor είναι το μέγεθος του buffer και είναι 
sizeof(int) μέγεθος, ώστε να γνωστοποιηθεί το buffer size και να χρησιμοποιηθεί σε όλα τα επόμενα μηνύματα 
και στέλνεται με την συνάρτηση write. 

Όλα τα υπόλοιπα μηνύματα που ανταλλάσσονται γίνονται μέσω των συναρτήσεων send_message και receive_message 
που υλοποίησα, και φαίνονται στο αρχείο common.h και common.c. Στην send_message στέλνεται πρώτα το μέγεθος 
του μηνύματος προς αποστολή ανά buffer_size bytes* που είναι μεγέθους int και το διαβάζει η receive_message 
ξέροντας ότι το μέγεθος είναι int. Έπειτα στέλνετε το πραγματικό μήνυμα και η receive, αφού ξέρει το μέγεθος 
από το προηγούμενο μήνυμα που αντάλλαξαν, ξέρει πόσα bytes να περιμένει.
Σημείωση:
*Το buffer_size λειτουργεί και για μικρό αριθμό bytes, μικρότερο από 4 bytes που είναι το μέγεθος του 
ακεραίου, καθώς και ο ακέραιος διασπάται σε κομματια μεγέθους buffer_size, όπως και το κύριο μήνυμα. 

Οι ενέργειες μέχρι το σημείο των εντολών από τον χρήστη γίνονται με συγκεκριμένη σειρά οπότε μετά από κάθε 
"ενότητα" μηνυμάτων στέλνετε ένα μήνυμα END ώστε να ενημερώσει η μία διεργασία την άλλη ότι τελείωσε αυτή 
η ενέργεια και να προχωρήσει στην επόμενη. 

Πιο συγκεκριμένα έπειτα από το buffer_size, το travelMonitor στέλνει στα monitor το size_of_bloom. Έπειτα 
τους μοιράζει τα subdirectories αλφαβητικά ένα ένα με round robin, διαβάζοντας το input dir με την scandir 
με όρισμα alphasort. Ενημερώνει όλα τα monitor στέλνοντας END ότι σταμάτησε να τους μοιράζει directories. 
Έπειτα, περιμένει τα monitor να ανοίξουν κάθε αρχείο στα directories που τους έχουν ανατεθεί και να 
ενημερώσουν κατάλληλα τις δομές που κρατάνε τις πληροφορίες (αυτό γίνεται με την συνάρτηση update_structures 
που περιλαμβάνει το αντίστοιχο κομμάτι κώδικα της πρώτης εργασίας, και χρησιμοποιεί τις ίδιες δομές), να 
στείλουν πίσω τα bloomfilters για κάθε ίωση την οποία έφτιαξαν. Εδώ χρησιμοποιώ την συνάρτηση select έτσι 
ώστε να διαβάζονται πρώτα τα πιο γρήγορα monitor και να γίνεται πιο γρήγορα η διαδικασία συνολικά. Το 
travelMonitor περιμένει ένα END από κάθε monitor ώστε να περάσει στο επόμενο monitor ή να τερματίσει την 
διαδικασία αν έχει πάρει ένα από κάθε monitor. Το travelMonitor περιμένει τώρα εντολές από το χρήστη και το 
monitor περιμένει εντολές από το travelMonitor μέσω named pipes. 


Για την αποστολή των bloomfilters γίνεται serialization στην αποστολή και deserialization στην παραλαβή 
επειδή περιέχει pointer, και θεωρείται γνωστή η δομή του (στο bloom_filter.h) για πιο εύκολη διαχείριση. 
Αυτές οι δύο συναρτήσεις βρίσκονται στο common.c.


bloomfilter_add
Το travelMonitor κρατάει μόνο τα bloom filters με key τον ιό στον οποίο ανήκουν. Υπάρχει μόνο ένα 
bloomfilter για έναν ιό. Αν έρθει ένα bloomfilter για ιό που ήδη υπάρχει τότε γίνεται bitwise OR ώστε να 
συγχωνευτούν σε ένα bloomfilter.


Signals

Θεωρώ ότι τα signals ερχονται όταν το πρόγραμμα είναι σε stable/idle κατάσταση.

Το signal sigint στα monitors που δημιουργεί το log file ανεβάζει μία σημαία. Η σημαία αυτή ελέγχεται στα 
σημεία που μπορεί να υπάρχει αλλαγή στο log file και επίσης δεν διακόπτει λειτουργίες. Το SIGINT στα παιδιά 
δεν τα κάνει interrupt, παρά μόνο φτιάχνει το log_file

Το σήμα SIGUSR1 στελνετε από το travelMonitor όταν αυτό δέχεται commands, που σημαίνει ότι το monitor έχει 
ήδη τελειώσει μέχρι και την αποστολή των bloom filters και περιμένει εντολές από το travelMonitor. Έτσι ο 
έλεγχος για SIGUSR1 γίνεται από εκείνο το σημείο και πέρα.

Το σήμα SIGCHLD το διαχειρίζεται το travelMonitor κάνοντας waitpid για όσα παιδιά έχουν πεθάνει, οπότε πιάνει
 και την περίπτωση να γίνουν πολλαπλά replace αν έχουν πεθάνει πολλά παιδιά από το ίδιο kill.


Εντολές

Στο /travelRequest πρώτα ελέγχεται αν τα ορίσματα είναι της σωστής μορφής, και έπειτα ελέγχεται επίσης αν 
υπάρχουν οι χώρες countryFrom και countryTo. Αν έστω μία από τις δυο δεν υπάρχει εκτυπώνεται μήνυμα. Αν ο 
ιός δεν υπάρχει τότε αυτό θα βρεθεί γιατί δεν θα υπάρχει κλειδί με το όνομα του ιού στο hash table των 
bloomfilters οπότε εκτυπώνεται μήνυμα.

Στο /travelStats δεν ελέγχεται αν δεν υπάρχει η χώρα που δίνεται, απλά αν δεν υπάρχει δεν θα αυξηθούν ποτέ 
οι μετρητές των rejected και accepted και η έξοδος θα γράφει ότι τα accepted και rejected είναι 0. Τα stats 
μετρουνται με τις συναρτήσεις του stats.h.

Στο /addVaccinationRecords το monitor που διαχειρίζεται τον συγκεκριμένο κατάλογο, ανανεώνει τις δομές του 
και στέλνει πίσω στο travelMonitor μόνο τα bloom filters τα οποία υπέστησαν αλλαγές. Αυτά το travelMonitor 
τα προσθέτει στα ήδη υπάρχοντα bloomfilter με την bloomfilter_add. read_files

Στο /searchVaccinationStatus το travelMonitor  προωθεί το αίτημα σε όλα τα monitors μέσω named pipes. Τα 
monitors κοιτάνε στο hash table των πολιτών. Μόνο σε ένα (ή κανένα) monitor θα βρεθεί ο πολίτης με το id 
επειδή έχουμε υποθέσει ότι ένας πολίτης έχει πάντα τα 5 πεδία του (citizenID firstName lastName country age) 
σωστά, χωρίς inconsistencies, διότι αλλιώς τα monitors θα έπρεπε να είχαν και επικοινωνία μεταξύ τους για 
να απορρίψουν τον πολίτη, πράγμα το οποίο δεν συμβαίνει. Έτσι μόνο το monitor το οποίο διαχειρίζεται την 
χώρα αυτού του citizenID θα απαντήσει. To travelMonitor χρησιμοποιεί την select για να βρει το pipe από το 
οποίο του έρχεται η απάντηση. Για την περίπτωση που το citizenID δεν υπάρχει σε κανένα monitor έχει οριστεί 
με το struct timeval ένα timeout στην select (5 δευτερολέπτων).


Logfiles
Το travelMonitor όταν δέχεται ή απορρίπτει αίτημα από την travelRequest στέλνει στο monitor που διαχειρίζεται 
την χώρα countryTo ACCEPTED η REJECTED ωστε το monitor να ενημερώσει τον μετρητή του. To travelMonitor εχει 2 
δικους του μετρητές για το logfile. Τα accepted και rejected των monitors, αν αθροιστούν δίνουν αυτά του 
travelMonitor.


update_structures
Έγινε τροποποίηση στον κώδικα της 1ης εργασίας ώστε η update_structures να παίρνει σαν όρισμα ένα hash table 
με τα updated entries που έχουν τροποποιήσει το πεδίο bloomfilters. 


replace child
Τα named pipes γίνονται close και open ξανά ώστε να συγχρονιστούν και να μπορούν να δουλέψουν όπως πριν. 
Έπειτα γίνεται η ίδια διαδικασία με την αρχική.
